name: Update Lines of Code in Readme

on:
  push:
    branches:
      - main
  schedule:
    - cron: "0 0 * * 0" # Runs weekly on Sunday at midnight (UTC)
  workflow_dispatch: # Allows manual trigger

jobs:
  count-lines:
    runs-on: ubuntu-latest
    env:
      # Check cloc docs for supported languages and exact names (e.g., "Vuejs Component", "C#")
      # HIGHLIGHT_LANGS: show these languages individually; everything else goes to "Others"
      HIGHLIGHT_LANGS: "JavaScript,TypeScript,JSX,Vuejs Component,PHP,C#"

      # IGNORE_LANGS: drop these languages entirely (not shown and not counted)
      IGNORE_LANGS: "JSON,HTML,CSS,SCSS,Sass,Markdown,SVG,XML,YAML,TOML,CSV,Text,Properties"

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      # Install required dependencies: jq (JSON processor), cloc (count lines of code), and locale settings
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq cloc locales
          sudo locale-gen en_US.UTF-8

      # Fetch public repositories (all repos user has access to) and clone only the default branch
      - name: Fetch and Clone Repositories
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          # Logging helper
          log() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
          }

          # Get GitHub user info
          log "Fetching GitHub user info..."
          USER_DATA=$(curl -H "Authorization: token $GH_PAT" -s "https://api.github.com/user")
          GH_USER=$(echo "$USER_DATA" | jq -r '.login')
          GH_EMAIL=$(echo "$USER_DATA" | jq -r '.email // empty')
          log "GitHub User: $GH_USER"
          log "GitHub Email: $GH_EMAIL"

          # Get a list of all repositories (owned + contributed to) that are not forks
          log "Fetching repository list..."
          REPOS=$(curl -H "Authorization: token $GH_PAT" -s "https://api.github.com/user/repos?per_page=100&affiliation=owner,collaborator,organization_member" | jq -r '.[] | select(.fork == false) | .full_name') || echo "Error fetching repositories"

          REPO_COUNT=$(echo "$REPOS" | wc -l)
          log "Found $REPO_COUNT repositories to clone"

          mkdir -p public-repos
          cd public-repos

          CLONED=0
          for REPO in $REPOS; do
            CLONED=$((CLONED + 1))
            REPO_URL="https://github.com/$REPO.git"
            AUTHENTICATED_REPO=$(echo "$REPO_URL" | sed "s/https:\/\//https:\/\/$GH_PAT@/g")

            # Determine the default branch dynamically
            DEFAULT_BRANCH=$(curl -H "Authorization: token $GH_PAT" -s "https://api.github.com/repos/$REPO" | jq -r '.default_branch')

            log "[$CLONED/$REPO_COUNT] Cloning $REPO (branch: $DEFAULT_BRANCH)..."
            git clone --quiet --branch "$DEFAULT_BRANCH" "$AUTHENTICATED_REPO" "$(basename $REPO)-$DEFAULT_BRANCH" || log "‚ùå Failed to clone $REPO"
          done

          log "Calculating lines of code..."
          mkdir -p ../output

          # Logging helper with timestamps
          log() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
          }

          # Count total contributors across all repos
          log "Analyzing repository contributors..."
          TOTAL_CONTRIBUTORS=0
          for REPO_DIR in */; do
            if [ -d "$REPO_DIR/.git" ]; then
              cd "$REPO_DIR"
              CONTRIBUTORS=$(git log --all --format='%ae' | sort -u | wc -l)
              if [ "$CONTRIBUTORS" -gt "$TOTAL_CONTRIBUTORS" ]; then
                TOTAL_CONTRIBUTORS=$CONTRIBUTORS
              fi
              cd ..
            fi
          done

          log "Maximum contributors in any repo: $TOTAL_CONTRIBUTORS"

          # OPTIMIZATION: If you're the only contributor, just count all code
          if [ "$TOTAL_CONTRIBUTORS" -le 1 ]; then
            log "Single contributor detected - counting all code (fast mode)"
            cloc . --json --report-file=../output/cloc-output.json --exclude-lang="${IGNORE_LANGS}"
          else
            # Multiple contributors - filter by author email
            log "Multiple contributors detected - filtering by author"
            mkdir -p ../user-code

            # Auto-discover all email addresses used by the user in commits
            log "Discovering user email addresses..."
            EMAILS=()

            # Add GitHub API email if available
            if [ -n "$GH_EMAIL" ]; then
              EMAILS+=("$GH_EMAIL")
            fi

            # Add common noreply patterns
            EMAILS+=("$GH_USER@users.noreply.github.com")

            # Discover all unique emails from commits across all repos
            ALL_EMAILS=$(for REPO_DIR in */; do
              if [ -d "$REPO_DIR/.git" ]; then
                cd "$REPO_DIR"
                git log --all --format='%ae'
                cd ..
              fi
            done | sort -u)

            # Filter emails that likely belong to the user
            # Matches: username, "neil", "javavirtualenv", or noreply patterns
            while IFS= read -r email; do
              if [[ "$email" == *"$GH_USER"* ]] || \
                 [[ "$email" == *"neil"* ]] || \
                 [[ "$email" == *"javavirtualenv"* ]] || \
                 [[ "$email" == *"noreply.github.com"* ]]; then
                EMAILS+=("$email")
                log "  ‚úì Found user email: $email"
              fi
            done <<< "$ALL_EMAILS"

            log "Total emails to match: ${#EMAILS[@]}"

            # Process each repo with optimizations
            REPO_COUNT=0
            for REPO_DIR in */; do
              if [ ! -d "$REPO_DIR/.git" ]; then
                continue
              fi

              cd "$REPO_DIR"
              REPO_COUNT=$((REPO_COUNT + 1))

              # Check user's commit percentage for logging
              TOTAL_COMMITS=$(git log --all --oneline | wc -l)

              # Count user commits by checking each email separately
              USER_COMMITS=0
              for email in "${EMAILS[@]}"; do
                COUNT=$(git log --all --author="$email" --oneline 2>/dev/null | wc -l || echo "0")
                USER_COMMITS=$((USER_COMMITS + COUNT))
              done

              if [ "$TOTAL_COMMITS" -gt 0 ]; then
                USER_PERCENT=$((100 * USER_COMMITS / TOTAL_COMMITS))
              else
                USER_PERCENT=0
              fi

              log "üìÇ Processing $REPO_DIR (${USER_PERCENT}% commits, $USER_COMMITS/$TOTAL_COMMITS)..."

              # OPTIMIZATION 1: Get only files touched by user (much faster than all files)
              # Collect files from all user emails
              USER_FILES=""
              for email in "${EMAILS[@]}"; do
                FILES=$(git log --all --author="$email" --name-only --pretty=format: 2>/dev/null || true)
                if [ -n "$FILES" ]; then
                  USER_FILES="$USER_FILES"$'\n'"$FILES"
                fi
              done
              USER_FILES=$(echo "$USER_FILES" | sort -u | grep -v '^$' || true)
              FILE_COUNT=$(echo "$USER_FILES" | grep -c '^' || echo "0")
              log "  Found $FILE_COUNT files modified by user"

              # OPTIMIZATION 2: Process files in parallel (8 at a time)
              echo "$USER_FILES" | xargs -P 8 -I {} bash -c '
                file="{}"
                if [ -f "$file" ]; then
                  mkdir -p "../user-code/'"$REPO_DIR"'$(dirname "$file")"

                  # Extract only user-authored lines
                  git blame --line-porcelain "$file" 2>/dev/null | \
                    awk -v emails="'"${EMAILS[*]}"'" '\''
                      BEGIN { split(emails, email_arr) }
                      /^author-mail / {
                        author_email=$0
                        sub(/^author-mail </, "", author_email)
                        sub(/>$/, "", author_email)
                      }
                      /^\t/ {
                        for (i in email_arr) {
                          if (author_email == email_arr[i]) {
                            print substr($0, 2)
                            break
                          }
                        }
                      }
                    '\'' > "../user-code/'"$REPO_DIR"'$file" 2>/dev/null || true
                fi
              '

              cd ..
            done

            log "Processed $REPO_COUNT repos"
            log "Running cloc on user-authored code..."

            # Run cloc on user-authored code only
            cd ../user-code
            cloc . --json --report-file=../output/cloc-output.json --exclude-lang="${IGNORE_LANGS}"

            log "‚úÖ Line counting complete!"
          fi

      # Commit and push the updated cloc-output.json and README.md to the current branch
      - name: Commit and Push Output
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          # Logging helper
          log() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
          }

          log "Configuring git..."
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Number formatting: enable thousands separators for all printf in this step
          # LC_ALL/LANG must be set before any printf that uses %'d

          # --- format helper ---
          format_number() {
            printf "%'d\n" "$1"
          }

          log "Generating README update..."

          # Ensure grouping is enabled for every printf in this step
          export LC_ALL="en_US.UTF-8"
          export LANG="en_US.UTF-8"

          # Grab total from cloc
          TOTAL_LINES=$(jq '.SUM.code // 0' output/cloc-output.json)

          OTHER_LINES=0
          FORMATTED_BREAKDOWN=""
          declare -A LANG_LINES

          # Normalize the highlight list for exact, comma-bounded matching (no false partial matches)
          HL=",$(echo "$HIGHLIGHT_LANGS" | tr -d ' '),"

          # First pass: collect all language data
          while read -r entry; do
            LANG=$(echo "$entry" | jq -r '.lang')
            LINES=$(echo "$entry" | jq -r '.lines')

            if [[ "$HL" == *",$LANG,"* ]]; then
              LANG_LINES["$LANG"]="$LINES"
            else
              OTHER_LINES=$((OTHER_LINES + LINES))
            fi
          done < <(
            jq -c 'to_entries
              | map(select(.key != "header" and .key != "SUM"))
              | map({lang: .key, lines: .value.code})
              | map(select(.lines > 0))
              | sort_by(-.lines)
              | .[]' output/cloc-output.json
          )

          # Second pass: sort languages by line count (descending) and format
          for LANG in $(for key in "${!LANG_LINES[@]}"; do echo "$key ${LANG_LINES[$key]}"; done | sort -rn -k2 | cut -d' ' -f1); do
            LINES="${LANG_LINES[$LANG]}"
            FORMATTED=$(format_number "$LINES")
            FORMATTED_BREAKDOWN+=$(printf "%-12s --> %s lines\n" "$LANG" "$FORMATTED")$'\n'
          done

          # "Others" includes all non-highlighted languages that cloc reported (after --exclude-lang); excluded ones never reach here
          if [[ $OTHER_LINES -gt 0 ]]; then
            FORMATTED_OTHER=$(format_number "$OTHER_LINES")
            FORMATTED_BREAKDOWN+=$(printf "%-12s --> %s lines\n" "Others" "$FORMATTED_OTHER")$'\n'
          fi

          # Format total ONCE (do not overwrite later)
          FORMATTED_TOTAL=$(format_number "$TOTAL_LINES")

          CODE_BLOCK="\`\`\`
          [ LANGUAGES BREAKDOWN ]

          $FORMATTED_BREAKDOWN
          [ TOTAL LINES OF CODE: $FORMATTED_TOTAL ]
          \`\`\`"

          # Replace content between markers. Requires these in README.md:
          # <!-- LANGUAGES BREAKDOWN START --> ... <!-- LANGUAGES BREAKDOWN END -->
          log "Updating README.md..."
          echo "$CODE_BLOCK" > temp_block.txt
          sed -i '/<!-- LANGUAGES BREAKDOWN START -->/,/<!-- LANGUAGES BREAKDOWN END -->/{
              //!d
              /<!-- LANGUAGES BREAKDOWN START -->/r temp_block.txt
          }' README.md

          rm temp_block.txt

          log "Committing changes..."
          git add output/cloc-output.json README.md
          git commit -m "chore: update README and cloc-output.json with latest code stats" || echo "No changes to commit"

          log "Pushing to GitHub..."
          git push origin HEAD

          log "‚úÖ Workflow complete!"
