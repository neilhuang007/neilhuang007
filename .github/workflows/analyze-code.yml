name: Update Lines of Code in Readme

on:
  push:
    branches:
      - main
  schedule:
    - cron: "0 0 * * 0" # Runs weekly on Sunday at midnight (UTC)
  workflow_dispatch: # Allows manual trigger

jobs:
  count-lines:
    runs-on: ubuntu-latest
    env:
      # IGNORE_LANGS: drop these languages entirely (not shown and not counted)
      IGNORE_LANGS: "JSON,HTML,CSS,SCSS,Sass,Markdown,SVG,XML,YAML,TOML,CSV,Text,Properties"

      # Display: Show top 5 languages by line count, everything else goes to "Others"

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      # Install required dependencies: jq (JSON processor), cloc (count lines of code), and locale settings
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq cloc locales
          sudo locale-gen en_US.UTF-8

      # Fetch public repositories (all repos user has access to) and clone only the default branch
      - name: Fetch and Clone Repositories
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          # Logging helper
          log() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
          }

          # Get GitHub user info
          log "Fetching GitHub user info..."
          USER_DATA=$(curl -H "Authorization: token $GH_PAT" -s "https://api.github.com/user")
          GH_USER=$(echo "$USER_DATA" | jq -r '.login')
          GH_EMAIL=$(echo "$USER_DATA" | jq -r '.email // empty')
          log "GitHub User: $GH_USER"
          log "GitHub Email: $GH_EMAIL"

          # Get a list of all repositories (owned + contributed to) that are not forks
          log "Fetching repository list..."
          REPOS=$(curl -H "Authorization: token $GH_PAT" -s "https://api.github.com/user/repos?per_page=100&affiliation=owner,collaborator,organization_member" | jq -r '.[] | select(.fork == false) | .full_name') || echo "Error fetching repositories"

          REPO_COUNT=$(echo "$REPOS" | wc -l)
          log "Found $REPO_COUNT repositories to clone"

          mkdir -p public-repos
          cd public-repos

          CLONED=0
          for REPO in $REPOS; do
            CLONED=$((CLONED + 1))
            REPO_URL="https://github.com/$REPO.git"
            AUTHENTICATED_REPO=$(echo "$REPO_URL" | sed "s/https:\/\//https:\/\/$GH_PAT@/g")

            # Determine the default branch dynamically
            DEFAULT_BRANCH=$(curl -H "Authorization: token $GH_PAT" -s "https://api.github.com/repos/$REPO" | jq -r '.default_branch')

            log "[$CLONED/$REPO_COUNT] Cloning $REPO (branch: $DEFAULT_BRANCH)..."
            git clone --quiet --branch "$DEFAULT_BRANCH" "$AUTHENTICATED_REPO" "$(basename $REPO)-$DEFAULT_BRANCH" || log "âŒ Failed to clone $REPO"
          done

          log "Calculating lines of code..."
          mkdir -p ../output

          # Logging helper with timestamps
          log() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
          }

          # Initialize commit counters
          TOTAL_USER_COMMITS=0
          TOTAL_ALL_COMMITS=0

          # Count total contributors across all repos
          log "Analyzing repository contributors..."
          TOTAL_CONTRIBUTORS=0
          for REPO_DIR in */; do
            if [ -d "$REPO_DIR/.git" ]; then
              cd "$REPO_DIR"
              CONTRIBUTORS=$(git log --all --format='%ae' | sort -u | wc -l)
              if [ "$CONTRIBUTORS" -gt "$TOTAL_CONTRIBUTORS" ]; then
                TOTAL_CONTRIBUTORS=$CONTRIBUTORS
              fi
              cd ..
            fi
          done

          log "Maximum contributors in any repo: $TOTAL_CONTRIBUTORS"

          # OPTIMIZATION: If you're the only contributor, just count all code
          if [ "$TOTAL_CONTRIBUTORS" -le 1 ]; then
            log "Single contributor detected - counting all code (fast mode)"
            cloc . --json --report-file=../output/cloc-output.json --exclude-lang="${IGNORE_LANGS}"

            # Count commits for single contributor (all commits are user's)
            log "Counting commits..."
            for REPO_DIR in */; do
              if [ -d "$REPO_DIR/.git" ]; then
                cd "$REPO_DIR"
                REPO_COMMITS=$(git log --all --oneline 2>/dev/null | wc -l)
                TOTAL_USER_COMMITS=$((TOTAL_USER_COMMITS + REPO_COMMITS))
                TOTAL_ALL_COMMITS=$((TOTAL_ALL_COMMITS + REPO_COMMITS))
                cd ..
              fi
            done
            log "âœ… Single contributor commits: $TOTAL_USER_COMMITS"

            # Add commit stats to cloc output
            cd ..
            jq --argjson user_commits "$TOTAL_USER_COMMITS" \
               --argjson total_commits "$TOTAL_ALL_COMMITS" \
               '. + {commits: {user: $user_commits, total: $total_commits}}' \
               output/cloc-output.json > output/cloc-output.json.tmp && \
               mv output/cloc-output.json.tmp output/cloc-output.json
          else
            # Multiple contributors - filter by author email
            log "Multiple contributors detected - filtering by author"

            # Auto-discover all email addresses used by the user in commits
            log "Discovering user email addresses..."
            EMAILS=()

            # Add GitHub API email if available
            if [ -n "$GH_EMAIL" ]; then
              EMAILS+=("$GH_EMAIL")
            fi

            # Add common noreply patterns
            EMAILS+=("$GH_USER@users.noreply.github.com")

            # Discover all unique emails from commits across all repos
            ALL_EMAILS=$(for REPO_DIR in */; do
              if [ -d "$REPO_DIR/.git" ]; then
                cd "$REPO_DIR"
                git log --all --format='%ae'
                cd ..
              fi
            done | sort -u)

            # Filter emails that likely belong to the user
            # Matches: username, "neil", "javavirtualenv", or noreply patterns
            while IFS= read -r email; do
              if [[ "$email" == *"$GH_USER"* ]] || \
                 [[ "$email" == *"neil"* ]] || \
                 [[ "$email" == *"javavirtualenv"* ]] || \
                 [[ "$email" == *"noreply.github.com"* ]]; then
                EMAILS+=("$email")
                log "  âœ“ Found user email: $email"
              fi
            done <<< "$ALL_EMAILS"

            log "Total emails to match: ${#EMAILS[@]}"

            # Process each repo with optimizations
            REPO_COUNT=0
            for REPO_DIR in */; do
              if [ ! -d "$REPO_DIR/.git" ]; then
                continue
              fi

              cd "$REPO_DIR"
              REPO_COUNT=$((REPO_COUNT + 1))

              # Check user's commit percentage for logging
              REPO_TOTAL_COMMITS=$(git log --all --oneline | wc -l)

              # Count user commits by checking each email separately
              REPO_USER_COMMITS=0
              for email in "${EMAILS[@]}"; do
                COUNT=$(git log --all --author="$email" --oneline 2>/dev/null | wc -l || echo "0")
                REPO_USER_COMMITS=$((REPO_USER_COMMITS + COUNT))
              done

              # Aggregate to global counters
              TOTAL_USER_COMMITS=$((TOTAL_USER_COMMITS + REPO_USER_COMMITS))
              TOTAL_ALL_COMMITS=$((TOTAL_ALL_COMMITS + REPO_TOTAL_COMMITS))

              if [ "$REPO_TOTAL_COMMITS" -gt 0 ]; then
                USER_PERCENT=$((100 * REPO_USER_COMMITS / REPO_TOTAL_COMMITS))
              else
                USER_PERCENT=0
              fi

              log "ðŸ“‚ Processing $REPO_DIR (${USER_PERCENT}% commits, $REPO_USER_COMMITS/$REPO_TOTAL_COMMITS)..."

              # NEW EFFICIENT ALGORITHM: Use git diff to count lines directly
              # Get all commits by user and count added lines per file

              # Build email grep pattern for faster filtering
              EMAIL_PATTERN=$(IFS='|'; echo "${EMAILS[*]}")

              # Get all user commit hashes for line counting
              USER_COMMIT_HASHES=$(git log --all --format='%H' --author-regexp --grep="$EMAIL_PATTERN" --all-match 2>/dev/null || \
                             git log --all --format='%H' $(printf -- '--author=%s ' "${EMAILS[@]}") 2>/dev/null || true)

              if [ -z "$USER_COMMIT_HASHES" ]; then
                log "  No commits found for user emails"
                cd ..
                continue
              fi

              # Count lines added per file using git log with numstat
              # This is much faster than git blame and gives us accurate contribution counts
              declare -A FILE_LINES

              for email in "${EMAILS[@]}"; do
                # Get stats: added lines, deleted lines, filename
                # Note: We count ALL contributions, including to files that may have been deleted
                # Process in awk to avoid bash subshell issues
                git log --all --author="$email" --pretty=tformat: --numstat 2>/dev/null | \
                  awk '$1 ~ /^[0-9]+$/ && NF >= 3 {
                    ext = $3
                    sub(/.*\./, "", ext)
                    if (index($3, ".") == 0) ext = "no_extension"
                    print $1 "|" ext "|" $3
                  }' >> "../temp_stats_$REPO_COUNT.txt"
              done

              log "  Collected contribution stats"

              cd ..
            done

            log "Processed $REPO_COUNT repos"
            log "Processing statistics and generating output..."

            # Process all temp stats files and aggregate by language
            cd ..

            # Define language mapping from file extensions (matching cloc's language names)
            declare -A EXT_TO_LANG=(
              # JavaScript/TypeScript
              ["js"]="JavaScript" ["jsx"]="JSX" ["ts"]="TypeScript" ["tsx"]="TypeScript"
              ["vue"]="Vuejs Component" ["mjs"]="JavaScript" ["cjs"]="JavaScript"

              # Web (ignored, but defined for completeness)
              ["html"]="HTML" ["htm"]="HTML" ["css"]="CSS" ["scss"]="SCSS" ["sass"]="Sass"
              ["json"]="JSON" ["xml"]="XML" ["svg"]="SVG" ["yaml"]="YAML" ["yml"]="YAML"

              # Backend
              ["php"]="PHP" ["java"]="Java" ["py"]="Python" ["rb"]="Ruby" ["go"]="Go"
              ["rs"]="Rust" ["cpp"]="C++" ["cc"]="C++" ["cxx"]="C++" ["c"]="C" ["h"]="C/C++ Header"
              ["cs"]="C#" ["kt"]="Kotlin" ["swift"]="Swift" ["m"]="Objective-C"

              # Shell/Config
              ["sh"]="Bourne Shell" ["bash"]="Bourne Again Shell" ["zsh"]="Zsh"
              ["toml"]="TOML" ["ini"]="INI" ["cfg"]="INI" ["properties"]="Properties"
              ["md"]="Markdown" ["txt"]="Text"

              # Other
              ["sql"]="SQL" ["graphql"]="GraphQL" ["proto"]="Protocol Buffers"
            )

            # Build ignore list from IGNORE_LANGS
            IFS=',' read -ra IGNORE_ARRAY <<< "$IGNORE_LANGS"
            declare -A IGNORE_MAP
            for lang in "${IGNORE_ARRAY[@]}"; do
              # Trim whitespace
              lang=$(echo "$lang" | xargs)
              IGNORE_MAP["$lang"]=1
            done

            # Aggregate statistics by language
            declare -A LANG_STATS_CODE
            declare -A LANG_STATS_FILES
            TOTAL_CODE=0
            TOTAL_FILES=0

            log "Aggregating statistics from temporary files..."
            for stats_file in public-repos/temp_stats_*.txt; do
              if [ -f "$stats_file" ]; then
                while IFS='|' read -r added ext filename; do
                  # Map extension to language
                  lang="${EXT_TO_LANG[$ext]:-$ext}"

                  # Check if language should be ignored
                  if [ -n "${IGNORE_MAP[$lang]}" ]; then
                    continue
                  fi

                  # Aggregate
                  LANG_STATS_CODE["$lang"]=$((${LANG_STATS_CODE[$lang]:-0} + added))
                  LANG_STATS_FILES["$lang"]=$((${LANG_STATS_FILES[$lang]:-0} + 1))
                  TOTAL_CODE=$((TOTAL_CODE + added))
                  TOTAL_FILES=$((TOTAL_FILES + 1))
                done < "$stats_file"
              fi
            done

            log "Generating cloc-compatible JSON output..."
            log "ðŸ“Š Total commits: $TOTAL_ALL_COMMITS (user: $TOTAL_USER_COMMITS)"

            # Use jq to generate valid JSON (avoids escaping issues)
            TIMESTAMP=$(date -u +'%Y-%m-%d %H:%M:%S')

            # Build JSON object using jq
            jq -n \
              --arg timestamp "$TIMESTAMP" \
              --argjson total_code "$TOTAL_CODE" \
              --argjson total_files "$TOTAL_FILES" \
              --argjson user_commits "$TOTAL_USER_COMMITS" \
              --argjson total_commits "$TOTAL_ALL_COMMITS" \
              '{
                header: {
                  cloc_version: "git-stats-1.0",
                  generated_at: $timestamp,
                  report_source: "git log --numstat"
                },
                SUM: {
                  blank: 0,
                  comment: 0,
                  code: $total_code,
                  nFiles: $total_files
                },
                commits: {
                  user: $user_commits,
                  total: $total_commits
                }
              }' > output/cloc-output.json

            # Add language entries using jq
            for lang in "${!LANG_STATS_CODE[@]}"; do
              code=${LANG_STATS_CODE[$lang]}
              files=${LANG_STATS_FILES[$lang]}

              jq --arg lang "$lang" \
                 --argjson code "$code" \
                 --argjson files "$files" \
                 '. + {($lang): {nFiles: $files, blank: 0, comment: 0, code: $code}}' \
                 output/cloc-output.json > output/cloc-output.json.tmp && \
                 mv output/cloc-output.json.tmp output/cloc-output.json
            done

            # Clean up temp files
            rm -f public-repos/temp_stats_*.txt

            log "âœ… Line counting complete! Total: $TOTAL_CODE lines across $TOTAL_FILES files"
          fi

      # Commit and push the updated cloc-output.json and README.md to the current branch
      - name: Commit and Push Output
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          # Logging helper
          log() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
          }

          log "Configuring git..."
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Number formatting: enable thousands separators for all printf in this step
          # LC_ALL/LANG must be set before any printf that uses %'d

          # --- format helper ---
          format_number() {
            printf "%'d\n" "$1"
          }

          log "Generating README update..."

          # Ensure grouping is enabled for every printf in this step
          export LC_ALL="en_US.UTF-8"
          export LANG="en_US.UTF-8"

          # Grab totals from cloc
          TOTAL_LINES=$(jq '.SUM.code // 0' output/cloc-output.json)
          USER_COMMITS=$(jq '.commits.user // 0' output/cloc-output.json)
          TOTAL_COMMITS=$(jq '.commits.total // 0' output/cloc-output.json)

          # Get top 5 languages by line count
          TOP_5_LANGS=$(jq -r 'to_entries
            | map(select(.key != "header" and .key != "SUM" and .key != "commits"))
            | sort_by(-.value.code)
            | .[0:5]
            | .[]
            | "\(.key)|\(.value.code)"' output/cloc-output.json)

          # Calculate "Others" (everything not in top 5)
          TOP_5_TOTAL=0
          FORMATTED_BREAKDOWN=""

          while IFS='|' read -r lang lines; do
            TOP_5_TOTAL=$((TOP_5_TOTAL + lines))
            FORMATTED=$(format_number "$lines")

            # Calculate percentage
            if [ "$TOTAL_LINES" -gt 0 ]; then
              PERCENTAGE=$(awk "BEGIN {printf \"%.1f\", ($lines / $TOTAL_LINES) * 100}")
            else
              PERCENTAGE="0.0"
            fi

            FORMATTED_BREAKDOWN+=$(printf "%-12s --> %s lines (%s%%)\n" "$lang" "$FORMATTED" "$PERCENTAGE")$'\n'
          done <<< "$TOP_5_LANGS"

          # Calculate "Others"
          OTHER_LINES=$((TOTAL_LINES - TOP_5_TOTAL))
          if [[ $OTHER_LINES -gt 0 ]]; then
            FORMATTED_OTHER=$(format_number "$OTHER_LINES")

            # Calculate percentage for Others
            if [ "$TOTAL_LINES" -gt 0 ]; then
              OTHER_PERCENTAGE=$(awk "BEGIN {printf \"%.1f\", ($OTHER_LINES / $TOTAL_LINES) * 100}")
            else
              OTHER_PERCENTAGE="0.0"
            fi

            FORMATTED_BREAKDOWN+=$(printf "%-12s --> %s lines (%s%%)\n" "Others" "$FORMATTED_OTHER" "$OTHER_PERCENTAGE")$'\n'
          fi

          # Format totals ONCE (do not overwrite later)
          FORMATTED_TOTAL=$(format_number "$TOTAL_LINES")
          FORMATTED_USER_COMMITS=$(format_number "$USER_COMMITS")
          FORMATTED_TOTAL_COMMITS=$(format_number "$TOTAL_COMMITS")

          # Calculate commit percentage
          if [ "$TOTAL_COMMITS" -gt 0 ]; then
            COMMIT_PERCENT=$(awk "BEGIN {printf \"%.1f\", ($USER_COMMITS / $TOTAL_COMMITS) * 100}")
          else
            COMMIT_PERCENT="0.0"
          fi

          CODE_BLOCK="\`\`\`
          [ LANGUAGES BREAKDOWN ]

          $FORMATTED_BREAKDOWN
          [ TOTAL LINES OF CODE: $FORMATTED_TOTAL ]
          [ COMMITS: $FORMATTED_USER_COMMITS personal / $FORMATTED_TOTAL_COMMITS total (${COMMIT_PERCENT}%) ]
          \`\`\`"

          # Replace content between markers. Requires these in README.md:
          # <!-- LANGUAGES BREAKDOWN START --> ... <!-- LANGUAGES BREAKDOWN END -->
          log "Updating README.md..."
          echo "$CODE_BLOCK" > temp_block.txt
          sed -i '/<!-- LANGUAGES BREAKDOWN START -->/,/<!-- LANGUAGES BREAKDOWN END -->/{
              //!d
              /<!-- LANGUAGES BREAKDOWN START -->/r temp_block.txt
          }' README.md

          rm temp_block.txt

          log "Committing changes..."
          git add output/cloc-output.json README.md
          git commit -m "chore: update README and cloc-output.json with latest code stats" || echo "No changes to commit"

          log "Pushing to GitHub..."
          git push origin HEAD

          log "âœ… Workflow complete!"
